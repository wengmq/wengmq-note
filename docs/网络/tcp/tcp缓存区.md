# [TCP 的发送缓冲区和接收缓冲区](https://www.cnblogs.com/saryli/p/9821058.html)

TCP 协议是作用是用来进行端对端数据传送的，那么就会有发送端和接收端，在操作系统有两个空间即 user space 和 kernal space。

每个 Tcp socket 连接在内核中都有一个发送缓冲区和接收缓冲区，TCP 的全双工的工作模式以及 TCP 的流量(拥塞)控制便是依赖于这两个独立的 buffer 以及 buffer 的填充状态。

- 单工：只允许甲方向乙方传送信息，而乙方不能向甲方传送 ，如汽车单行道。

- 半双工：半双工就是指一个时间段内只有一个动作发生，甲方可以向乙方传送数据，乙方也可以向甲方传送数据，但不能同时进行，如一条窄马路同一时间只能允许一个车通行。

- 全双工：同时允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。

一个 socket 的两端，都会有 send 和 recv 两个方法，如 client 发送数据到 server，那么就是客户端进程调用 send 发送数据，而 send 的作用是将数据拷贝进入 socket 的内核发送缓冲区之中，然后 send 便会在上层返回。

也就是说 **send()方法返回之时，数据不一定会发送到对端即服务器上去**（和 write 写文件有点类似），send()仅仅是把应用层 buffer 的数据拷贝进 socket 的内核发送 buffer 中，发送是 TCP 的事情，和 send 其实没有太大关系。

接收缓冲区把数据缓存入内核，等待 recv()读取，recv()所做的工作，就是把内核缓冲区中的数据拷贝到应用层用户的 buffer 里面，并返回。若应用进程一直没有调用 recv()进行读取的话，此数据会一直缓存在相应 socket 的接收缓冲区内。对于 TCP，如果应用进程一直没有读取，接收缓冲区满了之后，发生的动作是：收端通知发端，接收窗口关闭（win=0）。这个便是滑动窗口的实现。保证 TCP 套接口接收缓冲区不会溢出，从而保证了 TCP 是可靠传输。因为对方不允许发出超过所通告窗口大小的数据。 这就是 TCP 的流量控制，如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方 TCP 将丢弃它。

查看 socket 发送缓冲区大小，cat /proc/sys/net/ipv4/tcp_wmem

参考：https://www.cnblogs.com/saryli/p/9821058.html
