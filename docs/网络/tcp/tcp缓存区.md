# [TCP 的发送缓冲区和接收缓冲区](https://www.cnblogs.com/saryli/p/9821058.html)

TCP 协议是作用是用来进行端对端数据传送的，那么就会有发送端和接收端，在操作系统有两个空间即 user space 和 kernal space。

每个 Tcp socket 连接在内核中都有一个发送缓冲区和接收缓冲区，TCP 的全双工的工作模式以及 TCP 的流量(拥塞)控制便是依赖于这两个独立的 buffer 以及 buffer 的填充状态。

单工：只允许甲方向乙方传送信息，而乙方不能向甲方传送 ，如汽车单行道。

半双工：半双工就是指一个时间段内只有一个动作发生，甲方可以向乙方传送数据，乙方也可以向甲方传送数据，但不能同时进行，如一条窄马路同一时间只能允许一个车通行。

全双工：同时允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。

一个 socket 的两端，都会有 send 和 recv 两个方法，如 client 发送数据到 server，那么就是客户端进程调用 send 发送数据，而 send 的作用是将数据拷贝进入 socket 的内核发送缓冲区之中，然后 send 便会在上层返回。

也就是说 send()方法返回之时，数据不一定会

发送到对端即服务器上去（和 write 写文件有点类似），send()仅仅是把应用层 buffer 的数据拷贝进 socket 的内核发送 buffer 中，发送是 TCP 的事情，和 send 其实没有太大关系。

接收缓冲区把数据缓存入内核，等待 recv()读取，recv()所做的工作，就是把内核缓冲区中的数据拷贝到应用层用户的 buffer 里面，并返回。若应用进程一直没有调用 recv()进行读取的话，此数据会一直缓存在相应 socket 的接收缓冲区内。对于 TCP，如果应用进程一直没有读取，接收缓冲区满了之后，发生的动作是：收端通知发端，接收窗口关闭（win=0）。这个便是滑动窗口的实现。保证 TCP 套接口接收缓冲区不会溢出，从而保证了 TCP 是可靠传输。因为对方不允许发出超过所通告窗口大小的数据。 这就是 TCP 的流量控制，如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方 TCP 将丢弃它。

查看 socket 发送缓冲区大小，cat /proc/sys/net/ipv4/tcp_wmem
