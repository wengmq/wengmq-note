# awk命令

### 简介

awk 也是一个非常棒的数据处理工具!相较于 sed 常常作用于一整个行的处理， awk 则比较 倾向于一行当中分成数个“字段”来处理。因此，awk 相当的适合处理小型的数据数据处理呢!



### 基本用法

> ```
> awk 通常运行的模式是这样的:
> [dmtsai@study ~]$ awk '条件类型1{动作1} 条件类型2{动作2} ...' filename
> ```
>



awk 后面接两个单引号并加上大括号 {} 来设置想要对数据进行的处理动作。 awk 可以处理后 续接的文件，也可以读取来自前个指令的 standard output 。 但如前面说的， awk 主要是处 理“每一行的字段内的数据”，而默认的“字段的分隔符号为 "空白键" 或 "[tab]键" ”!举例来说， 我们用 last 可以将登陆者的数据取出来，结果如下所示:

> ```
> [dmtsai@study ~]$ last -n 5 <==仅取出前五行
> ```
>

```
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in 
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22) 
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12) 
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14) 
dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)
```

若我想要取出帐号与登陆者的 IP ，且帐号与 IP 之间以 [tab] 隔开，则会变成这样: 

> ```
> [dmtsai@study ~]$ last -n 5 | awk '{print $1 "\t" $3}'
> ```
>

dmtsai 192.168.1.100 
dmtsai 192.168.1.100
dmtsai 192.168.1.100 
dmtsai 192.168.1.100 
dmtsai Fri

上表是 awk 最常使用的动作!通过 print 的功能将字段数据列出来!字段的分隔则以空白键或 [tab] 按键来隔开。 因为不论哪一行我都要处理，因此，就不需要有 "条件类型" 的限制!我所 想要的是第一栏以及第三栏， 但是，第五行的内容怪怪的~这是因为数据格式的问题啊!所


 使用 awk 的时候，请先确认一下你的数据当中，如果是连续性的数据，请不要有空格或 [tab] 在内，否则，就会像这个例子这样，会发生误判喔!



另外，由上面这个例子你也会知道，在 awk 的括号内，**每一行的每个字段都是有变量名称 的，那就是 $1, $2... 等变量名称**。以上面的例子来说， dmtsai 是 $1 ，因为他是第一栏嘛! 至于 192.168.1.100 是第三栏， 所以他就是 $3 啦!后面以此类推~呵呵!还有个变量喔!那 就是 $0 ，$0 代表“一整列数据”的意思~以上面的例子来说，第一行的 $0 代表的就是“dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in  ”那一行啊! 由此可知，刚刚上面五行当中，整个 awk 的处理流程是:

> 1.读入第一行，并将第一行的数据填入$0,$1,$2....等变量当中;
>
> 2.依据"条件类型"的限制，判断是否需要进行后面的"动作";
>
> 3.做完所有的动作与条件类型;
>
> 4.若还有后续的“行”的数据，则重复上面1~3的步骤，直到所有的数据都读完为止。



### 内置变量

经过这样的步骤，你会晓得， awk 是“以行为一次处理的单位”， 而“以字段为最小的处理单 位”。好了，那么 awk 怎么知道我到底这个数据有几行?有几栏呢?这就需要 awk 的内置变 量的帮忙啦~


|变量名称| 代表意义|
| ---------------------------------- |
|NF| 每一行 ($0) 拥有的字段总数|
| NR |目前 awk 所处理的是“第几行”数据 |
| FS| 目前的分隔字符，默认是空白键 |

我们继续以上面 last -n 5 的例子来做说明，如果我想要:

- 列出每一行的帐号(就是 $1); 
- 列出目前处理的行数(就是 awk 内的 NR 变量)
-  并且说明，该行有多少字段(就是 awk 内的 NF 变量)

则可以这样:

> ```
> [dmtsai@study ~]$ last -n 5| awk '{print $1 "\t lines: " NR "\t columns: " NF}'
> ```
>

```
dmtsai   lines: 1        columns: 10
dmtsai   lines: 2        columns: 10
dmtsai   lines: 3        columns: 10
dmtsai   lines: 4        columns: 10
dmtsai   lines: 5        columns: 9
```

**Tips** 要注意喔，awk 后续的所有动作是以单引号“ ' ”括住的，由于单引号与双引号都必须是成 对的， 所以， awk 的格式内容如果想要以 print 打印时，记得非变量的文字部分，包含上一 小节 printf 提到的格式中，都需要使用双引号来定义出来喔!因为单引号已经是 awk 的指令 固定用法了!


注意喔，在 awk 内的 NR, NF 等变量要用大写，且不需要有钱字号 $ 啦!



### 逻辑运算

这样可以了解 NR 与 NF 的差别了吧?好了，下面来谈一谈所谓的 "条件类型" 了吧! awk 的逻辑运算字符

既然有需要用到 "条件" 的类别，自然就需要一些逻辑运算啰~例如下面这些:

| 运算单元 | 代表意义   |
| -------- | ---------- |
| >        | 大于       |
| <        | 小于       |
| >=       | 大于或等于 |
| <=       | 小于或等于 |
| ==       | 等于       |
| !=       | 不等于     |

值得注意的是那个“ == ”的符号，因为: 逻辑运算上面亦即所谓的大于、小于、等于等判断式上面，习惯上是以“ == ”来表示;

如果是直接给予一个值，例如变量设置时，就直接使用 = 而已。

好了，我们实际来运用一下逻辑判断吧!举例来说，在 /etc/passwd 当中是以冒号 ":" 来作为 字段的分隔， 该文件中第一字段为帐号，第三字段则是 UID。那假设我要查阅，第三栏小于 10 以下的数据，并且仅列出帐号与第三栏， 那么可以这样做:

> ```
> [dmtsai@study ~]$ cat /etc/passwd | awk '{FS=":"} $3 < 10 {print $1 "\t " $3}'
> ```
>

```
root:x:0:0:root:/root:/bin/bash
bin  					1
daemon 2
```

....(以下省略)....



有趣吧!不过，怎么第一行没有正确的显示出来呢?这是因为我们读入第一行的时候，那些 变量 $1, $2... 默认还是以空白键为分隔的，所以虽然我们定义了 FS=":" 了， 但是却仅能在第 二行后才开始生效。那么怎么办呢?我们可以预先设置 awk 的变量啊! 利用 **BEGIN 这个关 键字**喔!这样做:

> ```
>  [dmtsai@study ~]$ cat /etc/passwd | awk 'BEGIN {FS=":"} $3 &lt; 10 {print $1 "\t " $3}'
> ```
>

```
root 0  
bin 1 
daemon 2 
```

......(以下省略)......



很有趣吧!而除了 BEGIN 之外，我们还有 END 呢!另外，如果要用 awk 来进行“计算功 能”呢?以下面的例子来看， 假设我有一个薪资数据表文件名为 pay.txt ，内容是这样的:

```
  Name    1st     2nd     3th
  Bird2   43000   42000   41000
  VBird   23000   24000   25000 
  DMTsai  21000   20000   23000
```

如何帮我计算每个人的总额呢?而且我还想要格式化输出喔!我们可以这样考虑: 第一行只是说明，所以第一行不要进行加总 (NR==1 时处理);

- 第一行只是说明，所以第一行不要进行加总 (NR==1 时处理);
- 第二行以后就会有加总的情况出现 (NR>=2 以后处理)

```
[dmtsai@study ~]$ cat pay.txt | \
> awk 'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }
> NR>=2{total = $2 + $3 + $4
> printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'
 Name        1st        2nd        3th      Total
 VBird 23000 24000 25000 72000.00
 DMTsai 21000 20000 23000 64000.00
 Bird2 43000 42000 41000 126000.00
```

awk 的指令间隔:所有 awk 的动作，亦即在 {} 内的动作，**如果有需要多个指令辅助时， 可利用分号“;”间隔， 或者直接以 [Enter] 按键来隔开每个指令**，例如上面的范例中， 共按了三次 [enter] 喔! 逻辑运算当中，如果是“等于”的情况，则务必使用两个等号“==”!

上面的命令换成一行输出则是：

```
cat pay.txt | awk 'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" } NR>=2{total = $2 + $3 + $4 ;printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'
```



上面的例子有几个重要事项应该要先说明的:

- awk 的指令间隔:所有 awk 的动作，亦即在 {} 内的动作，如果有需要多个指令辅助时， 可利用分号“;”间隔， 或者直接以 [Enter] 按键来隔开每个指令，例如上面的范例中，鸟哥 共按了三次 [enter] 喔! 逻辑运算当中，
- 如果是“等于”的情况，则务必使用两个等号“==”!
- 格式化输出时，在 printf 的格式设置当中，务必加上 \n ，才能进行分行!

- 与 bash shell 的变量不同，在 awk 当中，变量可以直接使用，不需加上 $ 符号。



利用 awk 这个玩意儿，就可以帮我们处理很多日常工作了呢!真是好用的很~ 此外， awk 的输出格式当中，常常会以 printf 来辅助，所以， 最好你对 printf 也稍微熟悉一下比较好啦! 另外， awk 的动作内 {} 也是支持 if (条件) 的喔! 举例来说，上面的指令可以修订成为这 样:

```
cat pay.txt | awk '{if(NR==1) printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total"} NR>=2{total = $2 + $3 + $4 ;printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'
```

